{"name":"Holdup","tagline":"Wrangle CommonJS Promises.","body":"```\r\n /$$                 /$$       /$$\r\n| $$                | $$      | $$\r\n| $$$$$$$   /$$$$$$ | $$  /$$$$$$$ /$$   /$$  /$$$$$$\r\n| $$__  $$ /$$__  $$| $$ /$$__  $$| $$  | $$ /$$__  $$\r\n| $$  \\ $$| $$  \\ $$| $$| $$  | $$| $$  | $$| $$  \\ $$\r\n| $$  | $$| $$  | $$| $$| $$  | $$| $$  | $$| $$  | $$\r\n| $$  | $$|  $$$$$$/| $$|  $$$$$$$|  $$$$$$/| $$$$$$$/\r\n|__/  |__/ \\______/ |__/ \\_______/ \\______/ | $$____/\r\n                                            | $$\r\n                                            | $$\r\n                                            |__/\r\n```\r\n\r\n\r\n<a href=http://promises-aplus.github.com/promises-spec>\r\n  <img src=http://promises-aplus.github.com/promises-spec/assets/logo-small.png\r\n       align=right\r\n       alt='Promises/A+ logo'\r\n  />\r\n</a>\r\n\r\n\r\nHoldup is a small but full-featured flow-control library that makes working with\r\npromises or callbacks in Javascript easy. With Holdup you define the\r\ndependencies of your functions and it executes them for you with maximal\r\nconcurrency: you don't have to explicitly state whether they're parallel or\r\nserial, or what order each one should run in. It just works.\r\n\r\nHoldup runs in Node, Component-spec environments, and ordinary browsers; it has\r\nno dependencies and is extensively unit-tested. It works with any CommonJS\r\nPromises/A or Promises/A+ compliant promise implementation; it also provides\r\nits own Promises/A+ compliant promise implementation. It clocks in at a skinny\r\n3.7k minified and gzipped.\r\n\r\n\r\nExamples\r\n================================================================================\r\n\r\nHere's an example of how to define a task that depends on three other\r\nNode-style async functions:\r\n\r\n```javascript\r\nvar taskA = holdup.wrap(nodeFn);\r\nvar taskB = holdup.wrap(otherNodeFn);\r\nvar taskC = holdup.wrap(finalNodeFn, arg1, arg2);\r\n\r\nholdup.all(taskA, taskB, taskC).then(function() {\r\n  // do work\r\n}, function() {\r\n  // handle errors\r\n});\r\n```\r\n\r\nIn this case, `taskA`, `taskB`, and `taskC` will all immediately execute in\r\nparallel, and the work will wait until all three finish successfully. If any of\r\nthe dependencies fail, the error callback will be called. All of the tasks are\r\nthemselves just Promises/A+ compliant promises, so they can be used with any\r\nlibrary that works with Promises/A or Promises/A+.\r\n\r\nThat was a simple example, though: do some work in parallel, and when it\r\nfinishes do some other work. What if we have multiple dependencies on separate\r\nparallel workloads? Holdup handles that well too:\r\n\r\n```javascript\r\nvar taskA = holdup.wrap(fnA);\r\nvar taskB = holdup.wrap(fnB);\r\n\r\nvar taskC = holdup.all(taskA, taskB).then(function() {\r\n  return holdup.wrap(fnC);\r\n});\r\n\r\nvar taskD = holdup.all(taskA).then(function() { return holdup.wrap(fnD); });\r\n\r\nvar taskE = holdup.all(taskC, taskD).then(function() {\r\n  return holdup.wrap(fnE);\r\n});\r\n```\r\n\r\nIn the above, `taskE` depends both on `taskC` and `taskD`. `taskD` depends on\r\n`taskA`, as does `taskC` -- but `taskC` has an additional dependency on\r\n`taskB`. This might be a pain to hand-optimize with raw callbacks, but since\r\nyou just have to specify dependencies you can let Holdup take care of the work\r\nfor you.\r\n\r\nHoldup understands more than success, though. Sometimes things break; it's\r\nstill important to handle those failures. It might also be important to take\r\ncertain actions if specific combinations of things break. With Holdup, it's\r\neasy to define those relationships:\r\n\r\n```javascript\r\nvar taskA = holdup.wrap(fnA),\r\n    taskB = holdup.wrap(fnB),\r\n    taskC = holdup.wrap(fnC),\r\n    taskD = holdup.all(taskA, taskB),\r\n    taskE = holdup.none(taskC, taskD);\r\n\r\ntaskE.then(function() {\r\n  // only gets called when taskC and taskD both error out\r\n}, function() {\r\n  // gets called if either taskC or taskD pass, or if they both do\r\n});\r\n```\r\n\r\nSimilarly, Holdup has a `settled` function that fulfills once everything has\r\nresolved -- even if everything resolved to an error state, or if some resolved\r\none way and others resolved another. It passes inspection objects with\r\n`.value()` and `.error()` accessor methods to its callback:\r\n\r\n```javascript\r\nvar taskA = holdup.wrap(fnA),\r\n    taskB = holdup.wrap(fnB),\r\n    taskC = holdup.wrap(fnC),\r\n    taskD = holdup.resolved(taskA, taskB, taskC);\r\n\r\ntaskD.then(function(values) {\r\n  // this is called once taskA, taskB, and taskC are no longer in pending\r\n  // states.\r\n  // values is an array of Inspection objects with `.value()` and `.error()`\r\n  // accessor methods, along with state accessors like `.isFulfilled()` and\r\n  // `.isRejected()`.\r\n});\r\n```\r\n\r\nThe `all`, `none`, and `settled` primitives form much of the basis of Holdup's\r\nAPI, but they're not the only methods available. Holdup provides a\r\nfull-featured functional API for working with promises, wrapping Node-style\r\nfunctions, and easily making your own promises. Keep reading for the full API\r\ndocumentation.\r\n\r\n\r\nAPI\r\n================================================================================\r\n\r\nCreating Promises\r\n--------------------------------------------------------------------------------\r\n\r\n##### holdup.make(callback)\r\n\r\nGiven a callback of form `function(fulfill, reject) {}`, returns a promise that\r\nwill be fulfilled when the callback calls `fulfill` or rejected when the\r\npromise calls `reject`.\r\n\r\nThe returned promise will call its `then` callback with whatever is passed to\r\nthe `fulfill` callback, and will call its `then` errback with whatever is\r\npassed to the `reject` errback.\r\n\r\n\r\n##### holdup.fulfill(value)\r\n\r\nGiven a value, returns a promise that will fulfill to the value.\r\n\r\nEssentially a degenerate, but convenient form of `holdup.make` for creating\r\npromises that you know will fulfill to a specific value.\r\n\r\n\r\n##### holdup.fcall(fn)\r\n\r\nGiven a function that returns a value, returns a promise that will fulfill to\r\nthe result of the given function.\r\n\r\nEssentially a degenerate, but convenient form of `holdup.make` for creating\r\npromises that you know will fulfill to a specific value.\r\n\r\n\r\n##### holdup.reject(fn)\r\n\r\nGiven a reason, returns a promise that will reject with the reason.\r\n\r\nEssentially a degenerate but convenient form of `holdup.make` for creating\r\npromises that you know will reject to a specific value.\r\n\r\n\r\n##### holdup.ferr(fn)\r\n\r\nGiven a function that returns a value, returns a promise that will reject with\r\nthe result of the given function passed as the rejection reason.\r\n\r\nEssentially a degenerate but convenient form of `holdup.make` for creating\r\npromises that you know will reject to a specific value.\r\n\r\n\r\n\r\nManipulating Promises\r\n--------------------------------------------------------------------------------\r\n\r\n\r\n##### holdup.all(promises...)\r\n\r\nTakes an arg list, array, array of arrays, arg lists of arrays... etc\r\ncontaining promises.\r\n\r\nReturns a promise that will be fulfilled if all the promises fulfill, and will\r\nreject as soon as any of the promises reject.\r\n\r\nIt will call its `then` callback with the array of all fulfilled values, in the\r\norder that their respective promises were passed in. It will call its `then`\r\nerrback with the first promise to reject.\r\n\r\n\r\n##### holdup.none(promises...)\r\n\r\nTakes an arg list, array, array of arrays, arg list of arrays... etc containing\r\npromises.\r\n\r\nReturns a promise that will be fulfilled if all of the promises reject, and\r\nwill reject as soon as any of the promises fulfill.\r\n\r\nThe returned promise will call its `then` callback with the array of all\r\nrejected promises, in the order that they rejected. It will call its `then`\r\nerrback with the first promise to fulfill.\r\n\r\n\r\n##### holdup.settled(promises...)\r\n\r\n*alias: `holdup.resolved`, `holdup.allSettled`*\r\n\r\nTakes an arg list, array, array of arrays, arg list of arrays... etc containing\r\npromises.\r\n\r\nReturns a promise that will be fulfilled once all of the given promises are no\r\nlonger in a pending state; i.e., once they've each been rejected or fulfilled.\r\nThe promises don't have to end in the same state: they only have to leave the\r\npending state. The returned promise will never reject.\r\n\r\nThe returned promise will call its `then` callback with an array of promise\r\nInspection instances, with each inspection in the order that its respective\r\npromise was passed in.\r\n\r\n\r\n##### holdup.firstValue(promises...)\r\n\r\n*alias: `holdup.race`*\r\n\r\nTakes an arg list, array, array of arrays, arg list of arrays... etc containing\r\npromises.\r\n\r\nReturns a promise that will be fulfilled as soon as the first of the given\r\npromises fulfills, and will reject if none of the promises fulfill.\r\n\r\nThe returned promise will call its `then` callback with the first fulfilled\r\nvalue, and will call its `then` errback with the array of all rejected errors\r\nin the order that their respective promises were passed in.\r\n\r\n\r\n##### holdup.firstError(promises...)\r\n\r\nTakes an arg list, array, array of arrays, arg list of arrays... etc containing\r\npromises.\r\n\r\nReturns a promise that will be fulfilled as soon as the first of the given\r\npromises rejects, and will reject if none of the promises reject.\r\n\r\nThe returned promise will call its `then` callback with the first rejection\r\nreason, and will call its `then` errback with the array of all fulfilled values\r\nin the order that their respective promises were passed in.\r\n\r\n\r\n##### holdup.lastValue(promises...)\r\n\r\nTakes an arg list, array, array of arrays, arg list of arrays... etc containing\r\npromises.\r\n\r\nReturns a promise that will be fulfilled once all of the promises have left\r\ntheir pending state, and at least one has fulfilled. It will reject if all\r\ngiven promises reject.\r\n\r\nThe returned promise will call its `then` callback with the value of the last\r\nfulfilled promise, and will call its `then` errback with the array of all\r\nrejection reasons in the order that the respective promises were passed in.\r\n\r\n\r\n##### holdup.lastError(promises...)\r\n\r\nTakes an arg list, array, array of arrays, arg list of arrays... etc\r\ncontaining promises.\r\n\r\nReturns a promise that will be fulfilled once all of the promises have\r\nleft their pending state, and at least one has rejected. It will reject\r\nif all given promises fulfill.\r\n\r\nThe returned promise will call its `then` callback with the rejection reason\r\nof the last rejected promise, and will call its `then` errback with the array\r\nof all fulfilled promise values in the order that their respective promises\r\nwere passed in.\r\n\r\n\r\n##### holdup.invert(promise)\r\n\r\nGiven a promise, returns a promise that will reject when the given promise\r\nfulfills and will fulfill when the given promise rejects.\r\n\r\nIf data is passed to the callback of the given promise, it will be passed as\r\nthe error to the returned promise's errback. If an error is passed to the\r\nerrback of the given promise, it will be passed as the data to the returned\r\npromises callback.\r\n\r\n\r\n\r\nWorking With Values\r\n--------------------------------------------------------------------------------\r\n\r\n##### holdup.spread\r\n\r\n*alias: `holdup.spreadValues`*\r\n\r\nGiven a promise and a callback, calls the callback by applying the fulfilled\r\nvalue of the promise to the callback.\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar a = holdup.fulfill(10),\r\n    b = holdup.fulfill(11),\r\n    c = holdup.all(a, b);\r\n\r\nholdup.spread(c, function(aValue, bValue) {\r\n  // aValue is 10\r\n  // bValue is 11\r\n});\r\n```\r\n\r\n\r\n##### holdup.spreadErrors\r\n\r\nGiven a promise and a callback, calls the callback by applying the rejected\r\nerror of the promise to the callback.\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar a = holdup.reject(['nope', 'definitely not']),\r\n\r\nholdup.spreadErrors(a, function(firstError, secondError) {\r\n  // firstError is 'nope'\r\n  // secondError is 'definitely not'\r\n});\r\n```\r\n\r\n\r\n\r\nTiming Functions\r\n--------------------------------------------------------------------------------\r\n\r\n##### holdup.wait(milliseconds)\r\n\r\nGiven a time in milliseconds, returns a promise that calls its `then` callback\r\nafter that amount of time. The returned promise will never call any errback\r\nfunctions given to it.\r\n\r\nThe returned promise will pass along the given timeout interval to the `then`\r\ncallback as its first parameter.\r\n\r\n\r\n##### holdup.delay(promise, milliseconds)\r\n\r\nGiven a promise and a time in milliseconds, returns a promise that fulfills\r\nwhen the given promise fulfills or rejects when the first one rejects, but\r\nwaits the given time before fulfilling or rejecting.\r\n\r\n\r\n##### holdup.timeout(promise, milliseconds)\r\n\r\nGiven a promise and a time in milliseconds, returns a promise that fulfills if\r\nthe given promise fulfills before the time is up and rejects otherwise.\r\n\r\n\r\n\r\nIntegrating With Node-style Callback APIs\r\n--------------------------------------------------------------------------------\r\n\r\n##### holdup.napply(scope, nodeFn, args)\r\n\r\nGiven a scope, a Node-style async function, and an array of arguments, returns\r\na promise that fulfills if the given function completes successfully and\r\nrejects if it doesn't.\r\n\r\nThe returned promise will call its `then` callback with anything passed as the\r\n`data` parameter to the async function (if anything is in fact passed), and\r\nwill call its `then` errback with anything passed as the `err` param to the\r\nasync function.\r\n\r\n\r\n##### holdup.nfapply(nodeFn, args)\r\n\r\nA convenient, scopeless version of `napply`, for times when it's acceptable\r\nthat the scope of `napply` be `null`.\r\n\r\n\r\n##### holdup.ncall(scope, nodeFn, args...)\r\n\r\n*alias: `holdup.wrapFor`*\r\n\r\nGiven a scope, a Node-style async function, and optional arguments, returns a\r\npromise that fulfills if the given function completes successfully and rejects\r\nif it doesn't.\r\n\r\nThe returned promise will call its `then` callback with anything passed as the\r\n`data` parameter to the async function (if anything is in fact passed), and\r\nwill call its `then` errback with anything passed as the `err` param to the\r\nasync function.\r\n\r\n\r\n##### holdup.nfcall\r\n\r\n*alias: `holdup.wrap`*\r\n\r\nA convenient, scopeless version of `ncall`, for times when it's acceptable that\r\nthe scope of `ncall` be `null`.\r\n\r\n\r\n##### holdup.npost(obj, methodName, args)\r\n\r\nGiven an object, a method name corresponding to a Node-style async function,\r\nand an array of arguments, returns a promise that fulfills if the given method\r\ncompletes successfully and rejects if it doesn't.\r\n\r\nThe returned promise will call its `then` callback with anything passed as the\r\n`data` parameter to the async function (if anything is in fact passed), and\r\nwill call its `then` errback with anything passed as the `err` param to the\r\nasync function.\r\n\r\n\r\n##### holdup.ninvoke(obj, methodName, args...)\r\n\r\n*alias: `holdup.send`*\r\n\r\nGiven an object, a method name corresponding to a Node-style async function,\r\nand an optional argument list of parameters, returns a promise that fulfills if\r\nthe given method completes successfully and rejects if it doesn't.\r\n\r\nThe returned promise will call its `then` callback with anything passed as the\r\n`data` parameter to the async function (if anything is in fact passed), and\r\nwill call its `then` errback with anything passed as the `err` param to the\r\nasync function.\r\n\r\n\r\n##### holdup.nbind(nodeFn, scope, args...)\r\n\r\nGiven a Node-style async function, a scope, and an optional argument list of\r\nparameters, returns a promise-returning function bound to the scope and the\r\ngiven parameters.\r\n\r\nThe returned promise will call its `then` callback with anything passed as the\r\n`data` parameter to the async function (if anything is in fact passed), and\r\nwill call its `then` errback with anything passed as the `err` param to the\r\nasync function.\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar readProust = holdup.bind(fs.readFile, fs, 'proust.txt', 'utf-8');\r\nreadProust().then(function(text) {\r\n  // do things with text\r\n});\r\n```\r\n\r\n\r\n##### holdup.nfbind(nodeFn, args...)\r\n\r\n*alias: `holdup.denodeify`*\r\n\r\nA convenient, scopeless version of nbind, for times when it's acceptable that\r\nthe scope of `nbind` be `null`.\r\n\r\n\r\n##### holdup.nodeify(promise, callback)\r\n\r\nGiven a promise and a Node-style callback, calls the callback with the correct\r\n`data` and `err` arguments when the promise fulfills or rejects.  Useful for\r\ncreating dual promise/callback APIs, or for using promises internally but\r\nexposing only a callback API.\r\n\r\n\r\n\r\nPromise Methods\r\n--------------------------------------------------------------------------------\r\n\r\nPromises created by Holdup are Promises/A+ compliant and expose the following\r\nmethods:\r\n\r\n##### promise.then(onFulfilled, onRejected)\r\n\r\nGiven optional callbacks to be called on promise fulfillment or rejection,\r\nreturns a new promise that will adopt the state of the `onFulfilled` callback\r\nif `promise` fulfills, or will adopt the state of `promise` otherwise.\r\n\r\n\r\n##### promise.error(onRejected)\r\n\r\nAn alias for `promise.then(null, onRejected)`.\r\n\r\n\r\n##### promise.error(ErrorClass, onRejected)\r\n\r\nSimilar to a call to `promise.error(onRejected)`, except that `onRejected` will\r\nonly be called if the given rejection reason is an instance of `ErrorClass`.\r\n\r\n\r\n##### promise.thrown(onThrown)\r\n\r\n*alias: `promise.thrownError`*\r\n\r\n*:warning: Warning: `promise.thrown` is not interoperable with other\r\nPromises/A+ spec libraries; the Promises/A+ spec doesn't make it possible in a\r\ngeneral case to tell whether a promise has rejected due to a thrown error, or\r\nwhether it rejected for a different reason. If you need the functionality of\r\n`promise.thrown` — for example, if you're running in Node and follow the [Node\r\ncore team's recommendation to shutdown on thrown errors to avoid memory\r\nleaks][guide] — it's recommended that you not use Holdup in conjunction with\r\nother Promise libraries.*\r\n\r\n[guide]: http://nodejs.org/api/domain.html#domain_warning_don_t_ignore_errors\r\n\r\nSimilar to a call to `promise.then(null, onThrown)`, except that `onThrown`\r\nwill be called only if the promise rejects due to a thrown error.\r\n\r\n\r\n##### promise.thrown(ThrownClass, onThrown)\r\n\r\n*alias: `promise.thrownError`*\r\n\r\nSimilar to a call to `promise.thrown(onThrown)`, except that `onThrown` will be\r\ncalled only if the given rejection reason is an instance of `ThrownClass`.\r\n\r\n\r\n##### promise.unthrownError(onRejected)\r\n\r\nThe opposite of `promise.thrown`: the `onRejected` callback will only be called\r\nif the promise rejects without throwing an error (e.g. a Node-style function\r\npasses an error object back, rather than throwing an error).\r\n\r\n##### promise.unthrownError(ErrorClass, onRejected)\r\n\r\nSimilar to a call to `promise.unthrownError(onRejected)`, except that\r\n`onRejected` will be called only if the given rejection reason is an instance\r\nof `ErrorClass`.\r\n\r\n\r\n\r\nHandling Uncaught Errors\r\n--------------------------------------------------------------------------------\r\n\r\nThe Promises/A+ spec dictates that errors should never \"leak\" synchronously out\r\nof a promise: if you reject or throw an error, you'll never know unless you've\r\nattached an error handler (with `.then`, or the Holdup-specific `.error` or\r\n`.thrown` methods).\r\n\r\nSince often you'll want to take some action if an error occurs and is never\r\ncaught (for example, report it to your error logger, or gracefully restart your\r\nserver), Holdup provides events that fire when uncaught errors occur.\r\n\r\n##### holdup.on('error', fn)\r\n\r\nCalls `fn` if an uncaught rejection or thrown error occurs.\r\n\r\n\r\n##### holdup.on('thrown', fn)\r\n\r\nCalls `fn` if an uncaught thrown error occurs. Note that \"catching\" the error\r\nby handling it with an `onRejected` callback isn't enough: to prevent this from\r\nfiring, you must use a `.thrown` callback. Like `.thrown` and other\r\nthrown-error-specific code in Holdup, this is not compatible with other promise\r\nlibraries.\r\n\r\n\r\n##### holdup.off(type, fn)\r\n\r\nRemoves the given callback from listening to the type (`'error'` or `'thrown'`)\r\nof event.\r\n\r\n\r\n##### holdup.once(type, fn)\r\n\r\nCalls `holdup.on(type, fn)`, and then after the callback fires calls\r\n`holdup.off(type, fn)`.\r\n\r\n\r\n\r\nLicense\r\n================================================================================\r\n\r\nCopyright 2013-2014 Matt Baker. Licensed under the MIT License: see LICENSE.txt\r\nfor details.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}